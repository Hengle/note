<!-- TOC -->

- [1. 调用约定](#1-调用约定)
    - [1.1. prolog和epilog代码](#11-prolog和epilog代码)
        - [1.1.1. 头部代码：prolog代码](#111-头部代码prolog代码)
        - [1.1.2. 编译器的栈帧指针省略选项](#112-编译器的栈帧指针省略选项)
        - [1.1.3. 系统函数](#113-系统函数)
        - [1.1.4. 尾部代码：epilog代码](#114-尾部代码epilog代码)
        - [1.1.5. ENTER和LEAVE](#115-enter和leave)
- [2. Windows操作系统](#2-windows操作系统)
- [3. 其它](#3-其它)

<!-- /TOC -->
# 1. 调用约定
* cdecl，参数从右往左入栈，调用者清理栈，返回值位于EAX，C语言的标准调用约定
* stdcall，参数从右往左入栈，被调用者清理栈，返回值位于EAX，这个是Windows API的标准调用约定
* fastcall，先用EDX、ECX，再用栈传递参数，被调用者清理栈，返回值位于EAX
* C++调用约定 使用this指针
* VC提供了 thiscall调用， 将this 传递给ecx
* gc++中被当做静态变量，存放在栈顶
## 1.1. prolog和epilog代码
### 1.1.1. 头部代码：prolog代码
一个函数的prolog代码主要是为这个函数的执行做一些准备工作，例如设置堆栈帧、设置局部变量所使用的堆栈空间以及保存相关的寄存器等。标准的prolog代码开头一般为以下三条指令：
```x86asm
PUSH   EBP          // 保存上一个函数的栈帧
MOV    EBP, ESP     // 设置堆栈帧
SUB    ESP, XXX     // 为局部变量开辟空间，如果局部变量较少，编译器往往会使用类似于PUSH ECX这样的指令来开辟空间
//后面一般还有几条PUSH指令用于保存函数使用的寄存器（一般是EBX、ESI和EDI）
```
这三条指令为使用EBP寄存器来访问函数的参数（正偏移）和局部变量（负偏移）做好了准备。由于ESP会在函数执行期间变化，所以使用EBP寄存器（一般在整个函数中都不会变化）来作为栈帧指针。
### 1.1.2. 编译器的栈帧指针省略选项
大多数C/C++编译器都有栈帧指针省略（Frame-Pointer Omission）选项（在Microsoft C/C++编译器中为/Oy），它导致函数不使用堆栈帧，而是使用ESP来访问参数和局部变量，从而可以空闲出一个寄存器（EBP）用于其它目的，并稍微提高运行速度。但是在某些情况下必须使用堆栈帧，比如在使用了SEH的函数中。
### 1.1.3. 系统函数
在一些系统DLL如NTDLL.DLL中，许多函数的prolog代码的第一条指令并不是上面所说的`PUSH EBP`，而是一条垃圾指令`MOV EDI, EDI`（占两个字节），并且函数前面有五条NOP指令（占五个字节）。它们是微软对系统打热补丁时供Hook该API时用的，修补程序在五条NOP指令处写入一个远跳转指令（占五个字节），以跳转到被修补过的代码处。而`MOV EDI, EDI`处用一个近跳转指令（占两个字节）覆盖，它跳转到五个NOP指令所在的位置。使用`MOV EDI, EDI`而不是直接使用两个NOP指令是出于性能考虑。
### 1.1.4. 尾部代码：epilog代码
它主要做一些清理工作。标准代码如下：
```
// 前面可能还有几条POP指令用于恢复在prolog代码中保存的寄存器（如果存在的话）
MOV     ESP, EBP
POP     EBP
RET     XXX
```
最后的RET指令中的XXX指定了弹出的字节数，一般用于将参数弹出堆栈，因此从这个值就可以知道函数的参数个数（每个参数均为4字节）。
### 1.1.5. ENTER和LEAVE
为了简化操作，Intel引入了ENTER和LEAVE指令。其中ENTER相当于前面所说的prolog代码的前两条指令，而LEAVE相当于上面的epilog代码的前两条指令。但是由于实现上ENTER指令比前面所说的两条指令执行速度慢，因此编译器都不使用这条指令。这样，你实际看到的情况就 是：prolog代码就是前面所说的那样，但epilog代码使用了LEAVE指令。
# 2. Windows操作系统
* `\\?\`前缀告诉操作系统禁用字符串解析
* `\\ServerName\share`和`\\?\serverName\share`开头的文件为共享文件
* `\\.\`开头的文件为Win32设备名字空间，可以直接访问物理设备（Windows2003之后只能从Ring0访问）
* 备用数据流（ADS）允许附加数据添加到一个已存在的NTFS文件中，这个数据只有在访问流时才会可见，命名为normalFile.txt:Stream:$DATA
* 进程中每个线程共享内存空间，但是拥有自己的寄存器、CPU、栈
* 组件对象模型（COM）是一个接口标准，使用COM的线程必须在调用任何其它COM函数之前，至少一次调用OleInitialize或CoInitializeEx函数，COM对象通过全局唯一标识符（GUID=CLSID+IID）访问
* 原生API，参数粒度更细，提供信息更多，可以绕过普通API，NtContinue被用来从一个异常处理返回主线程，返回的位置可以被指定
* PE头的子系统指明了一个程序是不是原生应用程序
* 设置DR7寄存器中的通用探测标志位，任何通过mov指令访问调试寄存器的操作都会触发中断（别的指令不会触发）
* 调试器可能两次处理同一异常，调试器第一次捕获异常后将其传递给程序，程序无法处理时，会再次转给调试器，如果调试器不处理，程序就会崩溃
* 调试器会对INT3异常进行特殊处理，操作系统则不会
* 可以通过rundll和修改PE头的方式来运行dll文件
# 3. 其它
* 编译代码时，debug版本会遵循ebp规范，堆栈结构清晰，release版本会做大量代码优化，堆栈结构可能会出现混乱。但是在有try-catch机制的函数中，release版本不会做任何优化，以防堆栈结构出现错误
* VC6编译器，编译的所有异常处理函数名称永远是__except_handler3
* GUI（图形用户接口，使用微软已经画好的窗口）、GDI（图形设备接口，自己画窗口）
* GUI编程、GDI编程：HDC、窗口、画刷等等对象
* source insight工具，查看源代码