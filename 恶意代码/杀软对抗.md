# 杀软的自我保护
在WIN7 X64位系统后杀毒软件的自我保护一般都是通过OBOperationRegistration实现。当某些软件使用openprocess打开了杀毒软件的进程的时候,会触发这个回调,对openprocess的句柄进行降权操作.使得我们无法使用TerminateProcess、WriteProcessMemory、ReadProcessMemory这些需要用到HANDLE的东西对杀毒软件进行XXOO.也就实现了 “进程保护”
```c
VOID InstallCallBacks()
{
	NTSTATUS NtHandleCallback = STATUS_UNSUCCESSFUL;
	NTSTATUS NtThreadCallback = STATUS_UNSUCCESSFUL;
	OB_OPERATION_REGISTRATION OBOperationRegistration[2];
	OB_CALLBACK_REGISTRATION OBOCallbackRegistration;
	REG_CONTEXT regContext;
	UNICODE_STRING usAltitude;
	memset(&OBOperationRegistration, 0, sizeof(OB_OPERATION_REGISTRATION));
	memset(&OBOCallbackRegistration, 0, sizeof(OB_CALLBACK_REGISTRATION));
	memset(&regContext, 0, sizeof(REG_CONTEXT));
	regContext.ulIndex = 1;
	regContext.Version = 120;
	RtlInitUnicodeString(&usAltitude, L"1000");
	if ((USHORT)ObGetFilterVersion() == OB_FLT_REGISTRATION_VERSION)
	{


		OBOperationRegistration[1].ObjectType = PsProcessType;
		OBOperationRegistration[1].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
		OBOperationRegistration[1].PreOperation = ProcessHandleCallbacks;
		OBOperationRegistration[1].PostOperation = HandleAfterCreat;
		OBOperationRegistration[0].ObjectType = PsThreadType;
		OBOperationRegistration[0].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
		OBOperationRegistration[0].PreOperation = ThreadHandleCallbacks;
		OBOperationRegistration[0].PostOperation = HandleAfterCreat;
		OBOCallbackRegistration.Version = OB_FLT_REGISTRATION_VERSION;
		OBOCallbackRegistration.OperationRegistrationCount = 2;
		OBOCallbackRegistration.RegistrationContext = &regContext;
		OBOCallbackRegistration.OperationRegistration = OBOperationRegistration;
		NtHandleCallback = ObRegisterCallbacks(&OBOCallbackRegistration, &g_CallbacksHandle); // Register The CallBack
		if (!NT_SUCCESS(NtHandleCallback))
		{
			if (g_CallbacksHandle)
			{
				ObUnRegisterCallbacks(g_CallbacksHandle);
				g_CallbacksHandle = NULL;
			}
			DebugPrint("[DebugMessage] Failed to install ObRegisterCallbacks: 0x%08X.\n", NtHandleCallback);
		}
		else
			DebugPrint("[DebugMessage] Success: ObRegisterCallbacks Was Be Install\n");
	}
	PsSetCreateProcessNotifyRoutine(CreateProcessNotify, FALSE);
}
OB_PREOP_CALLBACK_STATUS ProcessHandleCallbacks(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation)
{
	UNREFERENCED_PARAMETER(RegistrationContext);
	if (g_MyPorcess == -1)
		return OB_PREOP_SUCCESS;
	if (OperationInformation->KernelHandle)
		return OB_PREOP_SUCCESS;
	PEPROCESS ProtectedProcessPEPROCESS;
	PEPROCESS ProtectedUserModeACPEPROCESS;
	PEPROCESS OpenedProcess = (PEPROCESS)OperationInformation->Object, CurrentProcess = PsGetCurrentProcess();
	ULONG ulProcessId = (ULONG)PsGetProcessId(OpenedProcess);
	ULONG myProcessId = (ULONG)PsGetProcessId(CurrentProcess);

	if (ulProcessId == g_MyPorcess) //如果进程我们的进程
	{
		if (OperationInformation->Operation == OB_OPERATION_HANDLE_CREATE) // 句柄降权
		{
			if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_TERMINATE) == PROCESS_TERMINATE)
			{
				//移除杀死进程的权限
				OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_TERMINATE;
			}
			if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_OPERATION) == PROCESS_VM_OPERATION)
			{
				OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_OPERATION;
			}
			if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_READ) == PROCESS_VM_READ)
			{
				OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_READ;
			}
			if ((OperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_WRITE) == PROCESS_VM_WRITE)
			{
				OperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_WRITE;
			}

		}
	}
	return OB_PREOP_SUCCESS;
```
# R3 Bypass
## 原理
理论上,之前的OBOperationRegistration实现的句柄保护已经够全面了.基本上R3的病毒木马是无法伤害到杀毒软件的.但是很多杀毒软件忽略了已经存在的具有完全读写权限的进程句柄 比如lsass.exe ，csrss.exe中存在的句柄(这个方法存在了很久很久,懂的人一直拿来默默使用,不公开,但国外的harakirinox在UC上发布了关于句柄劫持的方法而且还是完整的可以直接抄就用了导致这个方法泛滥然后被国外反作弊BE EAC修复,有意思的是TP在今年7月份国内的人在看雪论坛上发帖总结经验的时候还没有修复这个问题)

这里我们以火绒为例子

我们可以看到火绒的HipsTray.exe是无法被结束任务的